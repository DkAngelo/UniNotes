 > *Lezione del 15/03/2024*
 
Il concetto di ereditarietà parte dal voler creare delle nuove classi a partire da classi pre-esistenti. Per farlo bisogna creare la nuova classe in questo modo:
```
	public class <Nome-classe-figlia> extends <Nome-classe-padre>{
		//attributi che vogliamo aggiungere
	}
```
I costruttori, nelle classi figlie, prendono tutti gli attributi, e quindi anche quelli della classe padre
Java inoltre non supporta l'ereditarietà. Per fare riferimento nei costruttori a quegli attributi si usa la funzione `super()`.
La prassi chiede di non superare i cinque livelli di eredità.

## Upcasting e downcasting
 > *Upcasting:* assegno ad una variabile più piccola una variabile più grande
 > *Downcasting:* assegno ad una variabile più grande una variabile più piccola

Aldilà dei casting con i tipi primitivi, questo funziona anche con gli oggetti. Ad esempio:
```
Person person = new Client (...)
```
Sto assegnando ad un oggetto di tipo più specifico ad un oggetto più generico (*Client* è una classe figlia di *Person*). Lo svantaggio dell'upcasting usato in questo modo è la perdita di riferimento ad alcuni attributi, in quanto dati dal riferimento (in poche parole, person non avrà i getter utilizzati per gli attributi in più contenuti nella classe *Client*). Il grande vantaggio che però ho è dato dall'astrazione:
```
Person[] people = new Person[](programmer, client1, client2);
```
Dove *Programmer* è una classe figlia di secondo ordine, mentre *Client* di primo ordine. Entrambe sono accomunate da *Person*, quindi posso riferirmi a tutte e tre le entità attraverso i metodi e/o gli attributi contenuti nella classe *Person*.
Per tornare indietro, basta fare un downcasting per ritornare al riferimento precedente. Ad esempio:
```
Client client = (Client)p
```
Dove *p* era un oggetto della classe *Client* a cui era stato precedentemente cambiato il riferimento ad una classe di tipo *Person*.
